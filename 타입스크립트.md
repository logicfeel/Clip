## 타입스크립트

    ```typescript
    ```

### 구조
> 구조에 대해서 알아 본다.

- 기본타입
    - 부울 (Boolean)
    ```typescript
    let isDone: boolean = false;
    ```

    - 숫자형 (Number)
    ```typescript
    let decimal: number = 10;
    ```

    - 문자열 (String) 
    ```typescript
    let color: string = "blue";
    ```

    - 배열 (Array)
    ```typescript
    let list: number[] = [1, 2, 3];
    let list: Array<number> = [1, 2, 3]; // 제네릭 방식
    let list: [] // ?
    ```

    - 튜플 (Tuble)
    > 배열의 각각의 타입의 지정하는 방식
    ```typescript
    let x2: [string, number] = ["hello", 10]; // 좋아요
    ```

    - 열거 (Enum)
    ```typescript
    enum Color {Red, Green, Blue}
    let c: Color = Color.Green;
        
    // js로 변환시
    var Color;
    (function (Color) {
        Color[Color["Red"] = 0] = "Red";
        Color[Color["Green"] = 1] = "Green";
        Color[Color["Blue"] = 2] = "Blue";
    })(Color || (Color = {}));
    var c = Color.Green;

    // 속성을 2번 세팅한 효과를 가짐
    Color["Red"] = 0;   // 내부
    Color[0] = "Red";   // 외부
    
    //----------- 속성값을 임의로 지정 ----------
    // 지정한 수(10)에서 자동 증가됨
    enum Color {Red = 10, Green, Blue}  // 10,11,12
    ```

    - Any
    > c#의 Object 취상위 성격
    > 타입을 알지 못할때
     ```typescript
    let aaa: any = 4;
    ```

    - Void
    > Any의 반대 의미, 반환(return)이 없는 경우
    > undefined 타입만 선언 할당할 수 있음
     ```typescript
    let aaa: void = undefined;

    function warn() : void {
        alert("리턴타입이 없는 경우");
    }
    ```

    - Null 과 Undefined
    > 유용하지 않은 방법
    > 모든 타입은 null, undefined를 할당 가능
    > --strictNullChecks  옵션으로 void 타입에만 할당 가능
     ```typescript
    let u: undefined = undefined;
    let n: null = null;
    ```    

    - Never
    > 절대로 발생하지 않는 값, 예외
     ```typescript
    function error(msg: string): never {
        throw new Error(msg);
    }
    ```

    - 타입 단언 (Type assertions)
    > java의 강제캐스팅의 개념
     ```typescript
    let some: any = "ABCD";
    let value: number;

    // 강제로 타입 단언(캐스팅)
    value = (<string>some).length;      // 방법1
    value = (some as string).length;    // 방법2
    ```

    - let 에 대한 메모
-----------------------------------------
- 변수 선언
    - var 선언
        > var 의 결함을 피하기 위해서 : let, const
        >   - let : 타입을 선언하고 사용하는 방식
        >   - const : let 규칙 +  초기화 후 수정 불가
        >
        ```typescript
        var a = 10;
        ```

        - 스코프 규칙
        > var-scoping 또는 function-scoping
        ```typescript
        function f(shouldInitialize: boolean) {
            if (shouldInitialize) {
                var x = 10;
            }

            return x;
        }

        f(true);  // '10' 반환
        f(false); // 'undefined' 반환
        ```

        - 변수 캡쳐링의 단점
        ```typescript
        for (var i = 0; i < 10 ; i++) {
            
            // 변수가 캡쳐링 되어 모든 값이 '10'이 적됨
            setTimeout(function() { console.log(i); }, 100 * i);

            // IIEF 로 해결
            (function(i) {
                setTimeout(function() { console.log(i); }, 100 * i);
            })(i);
        }
        ```

    - let 선언
        - 블록-스코프
        > var과 차이점 블럭 스코프 외부에서는 사용 불가함
        > let은 선언 이전에 접근하면 오류 발생
        ```typescript
        let hello = "World!";

        function f(input: boolean) {
            let a = 100;

            if (input) {
                // 'a'는 이곳에서 가능
                let b = a + 1;
                return b;
            }

            // 오류: 'b'는 여기에 존재하지 않습니다.
            return b;
        }
        ```

        - 재선언과 Shadowing
        > var : 중복 선언 가능
        > let : 중복 선언 불가 (다른 블럭에 선언은 가능)
        > shadowing : 중첩된 블럭에서 기본 변수 이름 사용 (피해야함)
        ```typescript
        var x;
        var x;

        let x = 10;
        let x = 20; // 오류: 동일한 스코프에서 'x'를 다시 선언 할 수 없습니다.
        ```        

        - 블록-스코프 변수 캡쳐
        > var 과 let은 변환되는 방식이 다르다.
        ```typescript
        for (let i = 0; i < 10 ; i++) {
            setTimeout(function() { console.log(i); }, 100 * i);
        }

        // js 로 변환시 : 자동으로 변환하야 IIFE 블럭 사용을 피할 수 있다
        for (var i_1 = 0; i_1 < 10; i_1++) {
            _loop_1(i_1);
        }
        for (var i = 0; i < 10; i++) {
            setTimeout(function () { console.log(i); }, 100 * i);
        }
        ``` 

    - const 선언
    > - 상수 (타입은 지정 안함)
    > - 객체(클래스)에서 상수는 `readonly`지정
    > - const 외부 vs readonly 내부
    ```typescript
    const numLivesForCat = 9;
    
    const kitty = {
        name: "Aurora",
        numLives: numLivesForCat,
    }    
    ```

    - let vs const
    > 최소 권한 원칙 : const > let > var

    - 비구조화
        > 배열에 배열을 강제 할당하는 방식
        > 타입을 지정하지 않고, 배열:배열 방식으로 할당

        - 배열 비구조화
        ```typescript
        let input = [1, 2];
        let [first, second] = input;
        console.log(first); // 1 출력
        console.log(second); // 2 출력        
        // JS 변환시  -------------------
        var input = [1, 2];
        var first = input[0], second = input[1];

        // 동일함
        first = input[0];
        second = input[1];

        // 변수 교환
        [first, second] = [second, first];
        // JS 변환시  -------------------
        _a = [second, first], first = _a[0], second = _a[1];        

        // 특수한 경우들
        function f([first, second]: [number, number]) {
            console.log(first);
            console.log(second);
        }
        // JS 변환시  -------------------
        function f(_a) {
            var first = _a[0], second = _a[1];
            console.log(first);
            console.log(second);
        }

        let [first, ...rest] = [1, 2, 3, 4];
        console.log(first); // 1 출력
        console.log(rest); // [ 2, 3, 4 ] 출력
        // JS 변환시  -------------------
        var _b = [1, 2, 3, 4], first = _b[0], rest = _b.slice(1);

        let [first] = [1, 2, 3, 4];
        console.log(first); // 1 출력
        // JS 변환시  -------------------
        var first = [1, 2, 3, 4][0];

        let [, second, , fourth] = [1, 2, 3, 4];
        // JS 변환시  -------------------
        var _b = [1, 2, 3, 4], second = _b[1], fourth = _b[3];
        ```

        - 객체 비구조화
            > 객체를 해제(분리) 할때 사용
            ```typescript
            let o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            let { a, b } = o;
            // JS 변환시  -------------------
            var o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            var a = o.a, b = o.b;

            // 선언 없이 할당 (괄호를 묶는다)
            ({ a, b } = { a: "baz", b: 101 });
            // JS 변환시  -------------------
            (_b = { a: "baz", b: 101 }, a = _b.a, b = _b.b);
            
            // ... 구문으로 객체의 나머지를 변수로 해체할 수 있다
            let { a, ...passthrough } = o;
            let total = passthrough.b + passthrough.c.length;
            // JS변환,  -------------------
            var __rest = (this && this.__rest) || function (s, e) {
                var t = {};
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                    t[p] = s[p];
                if (s != null && typeof Object.getOwnPropertySymbols === "function")
                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                            t[p[i]] = s[p[i]];
                    }
                return t;
            };
            var o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            var a = o.a, passthrough = __rest(o, ["a"]);
            var total = passthrough.b + passthrough.c.length;
            ```

            - 프로퍼티 이름 변경
            > REVIEW:: 검토 필요!!
            ```typescript
            let { a: newName1, b: newName2 } = o;
            // JS 변환시  -------------------
            var newName1 = o.a, newName2 = o.b;
            ```

            - 기본값
            > 전달객체의 속성값이 없는경우 기본값을 지정 가능함
            ```typescript
            function keepWholeObject(wholeObject: { a: string, b?: number }) {
                let { a, b = 1001 } = wholeObject; // 기본값 지정
            }
            // JS 변환시  -------------------
            function keepWholeObject(wholeObject) {
                var a = wholeObject.a
                var _a = wholeObject.b
                var b = _a === void 0 ? 1001 : _a;
            }
            ```            
        - 함수 선언
        > 비구조화는 조심히사용 (혼란)
        ```typescript
        type C = { a: string, b?: number }
        function f({ a, b }: C): void {
            // ...
        }
        // JS 변환시  -------------------
        function f(_a) {
            var a = _a.a, b = _a.b;
            // ...
        }

        function f({ a, b = 0 } = { a: "" }): void {
            // ...
        }
        f({ a: "yes" }); // 좋아요, 기본값 b = 0
        f(); // 좋아요, 기본값은 { a:"" }이며 이 경우 기본값은 b = 0입니다.
        f({}); // 오류, 인수를 제공하려면 'a'가 필요합니다.
        ```

        - 전개 연산자
        > 비고조화의 반대의미
        > 배열 : 얕은 복사
        > 객체 : 왼쪽에서 오른쪽으로 진행하며 이전객체에 덮어씀
        > **주의사항**  객체의 복사시 메소드 복사 안됨
        ```typescript
        let first = [1, 2];
        let second = [3, 4];
        let bothPlus = [0, ...first, ...second, 5];
        // bothPlus에 [0, 1, 2, 3, 4, 5]

        let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
        let search = { ...defaults, food: "rich" }; // food 위치가 다름
        // search의 값은 { food: "rich", price: "$$", ambiance: "noisy" }

        let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
        let search = { ...defaults, food: "rich" }; // food 위치가 다름
        //search의 값은 { food: "spicy", price: "$$", ambiance: "noisy" }

        class C {
        p = 12;
        m() {
        }
        }
        let c = new C();
        let clone = { ...c };
        clone.p; // 좋아요
        clone.m(); // 오류!
        ```

-----------------------------------------
- 인터페이스
    > 타입-체커, 구조적 하위 유형화, 덕 타이핑
    > 인터페이스에 필요한 속성만 있으면됨

    - 첫번재 인터페이스
    ```typescript
    interface LabelledValue {
    label: string;
    }

    function printLabel(labelledObj: LabelledValue) {
    console.log(labelledObj.label);
    }
    ```

    - 선택적 프로퍼티
    > 속성명 뒤에 **?** 를 붙인다.
    ```typescript
    interface SquareConfig {
        color?: string;
        width?: number;
    }
    ```

    - 읽기 전용 프로퍼티
    > 속성명 앞에 **readonly** 를 붙인다.
    > 객체를 생성할때(`let`) 필수 입력(이후 수정불가)
    > - readonly : 프로퍼티(객체)
    > - const : 변수
    ```typescript
    interface Point {
        readonly x: number;
        readonly y: number;
    }

    let p1: Point = { x: 10, y: 20 };
    p1.x = 5; // 오류!

    let a: number[] = [1, 2, 3, 4];
    let ro: ReadonlyArray<number> = a;
    ro[0] = 12; // 오류!
    ro.push(5); // 오류!
    ro.length = 100; // 오류!
    a = ro; // 오류!
    
    // 타입 단언을 통해 오버라이딩 가능
    a = ro as number[]; // 성공
    ```

    - 프로퍼티 초과 검사
    > 선택으로 `선택적프로퍼티`외의 추가(초과)된 프로퍼티의 경우
    > 해결방법 : 타입단언, 객체할당
    > 기타 : 추가적인 프로퍼티를 interface에 정의하는 방법
    > - 선택적프로퍼티와 초과 검사를 같이 사용하면 안됨!
    ```typescript
    interface SquareConfig {
        color?: string;
        width?: number;
    }

    function createSquare(config: SquareConfig) {
        // ...
    }

    // 오류 : 'colour'는 'SquareConfig' 타입에서 필요하지 않습니다.
    let mySquare = createSquare({ colour: "red", width: 100 });

    // 우회방법1 : 타입 단언
    let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);

    // 우회방법2 : 객체 할당
    let squareOptions = { colour: "red", width: 100 };
    let mySquare = createSquare(squareOptions);

    // 추가 프로퍼티를 정의하는 방법
    interface SquareConfig {
        color?: string;
        width?: number;
        [propName: string]: any;    // 동적 프로퍼티 추가
    }
    ```

    - 함수 타입
    > 함수의 타입읠 정의 : 매개변수, 리턴타입
    > 매개변수 명은 일치할 필요 없음 `(source -> src)`
    ```typescript
    interface SearchFunc {
        (source: string, subString: string): boolean;
    }

    let mySearch: SearchFunc;
    mySearch = function(src: string, subString: string) {
        let result = source.search(subString);  // 함수 본문
        return result > -1;                     // 함수 본문
    };
    ```

    - 인덱싱 가능 타입
    > - 인덱스시그니처(동적속성)은 number, string 2가지 타입
    > - `숫자형 인덱서의 반환값은 문자열 인덱서 반환값의 하위여야함`
    >  `(string이 부모타입)`
    > - `"[name: string]: any" : 형식을 먼저 선언하는게 혼란을 피함`
    > - `강력하지만 모든 속성 반환유형이 일치하도록 강제함!!`
    > - 'readonly' 읽기전용 시그니처 사용 (프로퍼티이므로..)
    ```typescript
    class Animal {
        name: string;
    }
    class Dog extends Animal {
        breed: string;
    }
    
    interface NotOkay {
        [x: string]: Dog;
        [x: number]: Animal;    // 오류, string인덱스의 하위 타입이 아님
    }
    
    // 해결방법1, string인덱서에 상위 타입 선언하면 해결 (Animal)
    interface NotOkay {
        [x: string]: Animal;
        [x: number]: Dog;
    }

    // 해결방법2, 복합타입 선언
    interface NotOkay {
        [x: string]: Dog | Animal;
        [x: number]: Animal;
    }

    // 속성타입의 일치 우회방법
    interface NotOkay {
        [x: string]: Dog | Animal | string;
        [x: number]: Animal;
        color: string;  // 속성일치 우회 방법
    }

    interface NotOkay2 {
        [x: number]: Animal;
        [x: number]: Dog; // 오류, number 인덱스 중복
    }

    interface NotOkay2 {
        [x: string]: Animal;
        [x: string]: Dog; // 오류, string 인덱스 중복
    }

    // 읽기전용 시그니처
    interface ReadonlyStringArray {
    readonly [index: number]: string;
    }    
    ```

    - 클래스 타입
        - 인터페이스 구현
        > 인터페이스 구현이란? 인터페이스를 구현한 클래스 타입이다.
        > 인터페이스는 `public`의 클래스를 만듬
        ```typescript
        interface ClockInterface {
            currentTime: Date;
            setTime(d: Date);
        }

        class Clock implements ClockInterface {
            currentTime: Date;
            setTime(d: Date) {
                this.currentTime = d;
            }
            constructor(h: number, m: number) {}
        }
        ```

        - 클래스 스태틱과 인스턴스의 차이점
        > - interface 에 new 생성자 를 정의한 경우
        > - new 생성자 인터페이스는 구분하여 구현해야한다는 의미
        > REVIEW:: 어떤경우에 사용하는지 확인은 필요!
        ```typescript
        // 오류, 정적측면 검사안됨
        interface ClockConstructor {
            new (hour: number, minute: number); 
        }
        class Clock implements ClockConstructor {
            currentTime: Date;
            constructor(h: number, m: number) {}
        }

        // -----------------------
        // 생성자 함수를 구분하여 생성
        interface ClockConstructor { 
            new (hour: number, minute: number): ClockInterface;
        }
        interface ClockInterface {
            tick(): void;
        }

        function createClock(   // 생성자 함수
            ctor: ClockConstructor,
            hour: number,
            minute: number
        ): ClockInterface {
            return new ctor(hour, minute);
        }

        class DigitalClock implements ClockInterface {
            constructor(h: number, m: number) {}
            tick() {
                console.log("beep beep");
            }
        }
        let digital = createClock(DigitalClock, 12, 17);

        // -----------------------
        // 변수에 생성자 타입을 선언후 클래스를 할당하는 방식
        interface ClockConstructor {
            new (hour: number, minute: number): ClockInterface;
        }
        interface ClockInterface {
            tick(): void;
        }
        
        const Clock: ClockConstructor = class Clock implements ClockInterface {
            constructor(h: number, m: number) { }
            tick() {
                //....
            }
        }

        let i = new Clock(1, 2);
        i.tick()        
        ```

    - 인터페이스 확장
    > 인터페이스를 유연하게 사용할 수 있다.
    ```typescript
    interface Shape {
        color: string;
    }

    interface PenStroke {
        penWidth: number;
    }

    interface Square extends Shape, PenStroke {
        sideLength: number;
    }

    let square = <Square>{};
    square.color = "blue";
    square.sideLength = 10;
    square.penWidth = 5.0;
    ```

    - 하이브리드 타입
    > `**외부 서드-파티 JavaScript 와 상호작용할 경우 사용할 수 있음`
    ```typescript
    interface Counter {
        (start: number): string;    // 함수 타입  인터페이스
        interval: number;
        reset(): void;
    }

    function getCounter(): Counter {    // 함수 인터페이스

        // 아래와 같은 의미 (표현)
        //let counter = function(start: number) {} as Counter;
        let counter = <Counter>function(start: number) {};

        counter.interval = 123;
        counter.reset = function() {};
        return counter;
    }

    let c = getCounter();
    c(10);              // 함수로 사용
    c.reset();          // 메소드 사용
    c.interval = 5.0;   // 프로퍼티 사용
    ```

    - 인터페이스 확장 클래스
    > - 클래스타입을 인터페이스로 확장하면 모든 멤버(메소드,속성)이 선언됨
    > - 구현은 상속하지 않는다(제거됨)
    > - `주의` : 확장할 클래스에 private, protected 가 있으면 서브클래스의 구현부할 수 있음 (extends, implements)
    ```typescript
    class Control {
        private state: any;
    }

    interface SelectableControl extends Control {
        select(): void;
    }

    class Button extends Control implements SelectableControl {
        select() { }
    }

    // --------------------------
    // private, protected가 없는 경우
    class TextBox {
        select() {}
    }

    interface TextBoxInterface extends TextBox {
        view(): void;
    }

    class Text implements TextBoxInterface {
        select() { }    // 구현부
        view() { }      // 구현부
    }
    ```

-----------------------------------------
- 클래스
    - 클래스
    
    **간단한 예제**
    ```typescript
    class Greeter {
        greeting: string;
        constructor(message: string) {
            this.greeting = message;
        }
        greet() {
            return "Hello, " + this.greeting;
        }
    }

    let greeter = new Greeter("world");
    ```

    - 상속
    ```typescript
    class Animal {
        move(distanceInMeters: number = 0) {
            console.log("...");
        }
    }

    class Dog extends Animal {
        bark() {
            console.log('Woof! Woof!');
        }
    }

    const dog = new Dog();
    dog.bark();
    dog.move(10);
    dog.bark();
    // JS 변환시  -------------------
    var __extends = (this && this.__extends) || (function () {
        //상속 처리 영역..
    })();

    var Animal = /** @class */ (function () {
        function Animal() {
        }
        Animal.prototype.move = function (distanceInMeters) {
            if (distanceInMeters === void 0) { distanceInMeters = 0; }
            console.log("...");
        };
        return Animal;
    }());
    var Dog = /** @class */ (function (_super) {
        __extends(Dog, _super);
        function Dog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Dog.prototype.bark = function () {
            console.log('Woof! Woof!');
        };
        return Dog;
    }(Animal));
    var dog = new Dog();
    dog.bark();
    dog.move(10);
    dog.bark();    
    ```

    **복잡한 예제**
    ```typescript
    class Animal {  // 부모
        name: string;
        constructor(theName: string) { this.name = theName; }
        move(distanceInMeters: number = 0) {
            console.log(`${this.name} moved ${distanceInMeters}m.`);
        }
    }

    class Snake extends Animal {
        constructor(name: string) {     // 생성자, 선택
            super(name);                // 부모생성자 호출, 필수 (첫호출)
        }
        move(distanceInMeters = 5) {
            console.log("Slithering...");
            super.move(distanceInMeters);   // 데코레이션 패턴, 선택
        }
    }

    let sam = new Snake("Sammy the Python");
    let tom: Animal = new Snake("Tommy the Palomino");  // 상위타입 지정

    sam.move();
    tom.move(34);    
    ```

    - Public, private, protected 지정자

        - 기본적인 public
        > 기본 스코프 `public` (생략시)
        ```typescript
        class Animal {
            public name: string;
            public constructor(theName: string) { this.name = theName; }
            public move(distanceInMeters: number) {
                console.log(`${this.name} moved ${distanceInMeters}m.`);
            }
        }
        ```

        - private 이해하기
        > 자바스크립트에서 별도로 구분 안함
        ```typescript
        class Animal {
            private name: string;
            constructor(theName: string) { this.name = theName; }
        }

        new Animal("Cat").name; // 오류: 'name'은 private이다;
        // JS 변환시  -------------------
        var Animal = /** @class */ (function () {
            function Animal(theName) {
                this.name = theName;
            }
            return Animal;
        }());
        new Animal("Cat").name; // 오류: 'name'은 private이다;
        ```

        - protected 이해하기
        > - 상속한 자식에서는 사용가능함
        > - 외부에서는 사용 불가
        > ** JS기법
        > - this를 통해서 선언하고 이름으로 private `_name` 식으로 구분
        > - protected 는 사용을 피함
        > ** 다른 방법
        > - private 와 public 만 사용함
        > - private 의 경우 `var innner`; 식으로 선언
        ```typescript
        class Person {
            private inner: string;
            protected name: string;
            public color: string;
            protected constructor(name: string) {
                this.name = name;
            this.inner = name;
                this.color = "Blue";
                
            }
        }

        class Employee extends Person {
            constructor(name: string, department: string) {
                super(name);
            }

            public getElevatorPitch() {
                return this.name;
            }
        }

        let howard = new Employee("Howard", "Sales");
        let john = new Person("John"); // 오류: 'Person'의 생성자는 protected입니다.

        console.log(howard.getElevatorPitch());
        console.log(howard.name); // 오류
        console.log(howard.color);
        // JS 변환시  -------------------
        var Person = /** @class */ (function () {
            function Person(name) {
                this.name = name;       // protected 스코프
                this.inner = name;      // private 스코프
                this.color = "Blue";    // pubic 스코프
            }
            return Person;
        }());
        var Employee = /** @class */ (function (_super) {
            __extends(Employee, _super);
            function Employee(name, department) {
                return _super.call(this, name) || this;
            }
            Employee.prototype.getElevatorPitch = function () {
                return this.name;
            };
            return Employee;
        }(Person));
        var howard = new Employee("Howard", "Sales");
        var john = new Person("John"); // 오류: 'Person'의 생성자는 protected입니다.
        console.log(howard.getElevatorPitch());
        console.log(howard.name); // 오류
        console.log(howard.color);        
        ```

    - Readonly 지정자
        > ** JS기법
        > - 네이밍기법으로 우회 : 대문자 (NAME, NUMBER_OF_LEGS)
        ```typescript
        class Octopus {
            readonly name: string;
            readonly numberOfLegs: number = 8;
            constructor (theName: string) {
                this.name = theName;
            }
        }
        let dad = new Octopus("Man with the 8 strong legs");
        dad.name = "Man with the 3-piece suit"; // 오류! name은 readonly입니다.        
        ```

        - 매개변수 프로퍼티 (읽기전용)
        > 매개변수를 수정하면 안될때
        > JS기법 제외함
        ```typescript
        class Octopus {
            constructor(readonly name: string) {
            }
        }
        ```

    - 접근자 (getter/setter)
    ```typescript
    class Employee {
        private _fullName: string;

        get fullName(): string {
            return this._fullName;
        }

        set fullName(newName: string) {
            this._fullName = newName + "추가첨자";
        }
    }

    let employee = new Employee();
    employee.fullName = "Bob Smith";
    // JS 변환시  -------------------
    var Employee = /** @class */ (function () {
        function Employee() {
        }
        Object.defineProperty(Employee.prototype, "fullName", { // 내장함수 사용
            get: function () {
                return this._fullName;
            },
            set: function (newName) {
                this._fullName = newName + "추가첨자";
            },
            enumerable: true,
            configurable: true
        });
        return Employee;
    }());
    var employee = new Employee();
    employee.fullName = "Bob Smith";
    ```

    - 정적 프로퍼티 (static)
    ```typescript
    class Grid {
        static origin = 10;
        getOrigin(o: number) {
            Grid.origin = o;
        }
    }

    let grid1 = new Grid();
    console.log(Grid.origin);
    // JS 변환시  -------------------    
    var Grid = /** @class */ (function () {
        function Grid() {
        }
        Grid.prototype.getOrigin = function (o) {
            Grid.origin = o;
        };
        Grid.origin = 10;   // static 속성 설정
        return Grid;
    }());
    var grid1 = new Grid();
    console.log(Grid.origin);    
    ```

    - 추상 클래스
    > - 인터페이스와 달리 구현부를 포함할 수 있음
    > - 인스턴스 생성 불가
    > - JS 변환시 일반클래스와 같음
    > JS기법 제외함
    ```typescript
    abstract class Animal {
        abstract makeSound(): void;
        move(): void {
            console.log("roaming the earth...");
        }
    }    
    ```

    - 고급기법
        - 생성자 함수
        > REVIEW:: 필요할까?
        ```typescript
        ```

        - 클래스를 인터페이스로 사용하기 (인터페이스편에서.. )
        ```typescript
        class Point {
            x: number;
            y: number;
        }

        interface Point3d extends Point {
            z: number;
        }

        let point3d: Point3d = { x: 1, y: 2, z: 3 };
        ```

-----------------------------------------
- 함수
    - 함수
    > 기명함수 vs 익명함수
    ```typescript
    // 기명 함수
    function add(x, y) {
        return x + y;
    }

    // 익명 함수
    let myAdd = function(x, y) { return x + y; };
    ```

    - 함수의 타입
        - 함수 작성하기
        ```typescript
        function add(x: number, y: number): number {
            return x + y;
        }        
        ```        

        - 함수 타입 작성하기
        > 반환 타입을 `=>`로 표시
        ```typescript
        let myAdd: (x: number, y: number) => number =
            function(x: number, y: number): number { return x + y; };
        // JS 변환시  -------------------
        var myAdd = function (x, y) { return x + y; };                          
        ```

        - 타입 추론
        > 상황적 타이핑 x, y는 number 로 추론된다.
        ```typescript
        // myAdd는 완벽하게 함수 타입을 가지고 있습니다.
        let myAdd = function(x: number, y: number): number { return  x + y; };

        // 매개변수 'x'와 'y'에는 number 타입이 있습니다.
        let myAdd: (baseValue: number, increment: number) => number =
            function(x, y) { return x + y; };
        ```

    - 선택적 매개변수와 기본 매개변수
    > 매개변수`?` : 선택적 매개변수
    ```typescript
    function buildName(defName = "Will", firstName: string, lastName?: string) {
        return firstName + " " + lastName;
    }

    let result1 = buildName("Bob");                         // 오류, 너무 적은 매개변수
    let result2 = buildName("Bob", "Adams", "Sr.", "..");   // 오류, 너무 많은 매개변수
    let result3 = buildName("Bob", "Adams");                // 좋아요 "Bob Adams"를 반환합니다
    let result4 = buildName(undefined, "Adams");            // 좋아요 "Will Adams"를 반환합니다
    ```

    - 나머지 매개변수
    > 인수의 갯수를 모를때 arguments 를 이용함
    > - `...변수명`에 배열로 사용한다.
    ```typescript
    function buildName(firstName: string, ...restOfName: string[]) {
        return firstName + " " + restOfName.join(" ");
    }

    let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
    // JS 변환시  -------------------
    function buildName(firstName) {
        var restOfName = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            restOfName[_i - 1] = arguments[_i];
        }
        return firstName + " " + restOfName.join(" ");
    }
    var employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
    ```

    - this
        > REVIEW:: 별도의 페이지 제공
        > http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/

        - this와 화살표 함수
        > - 컴파일러에 --noImplicitThis 신호를 넘겨주면 TypeScript가 실수를 했을 때 경고
        ```typescript
        // return "function()" 사용시
        let deck = {
            suits: ["hearts", "spades", "clubs", "diamonds"],
            cards: Array(52),
            createCardPicker: function() {
                return function() {
                    return this.suits[0];
                }
            }
        }

        let cardPicker = deck.createCardPicker();
        let pickedCard = cardPicker();

        // return "() =>" 사용시
        let deck2 = {
            suits: ["hearts", "spades", "clubs", "diamonds"],
            cards: Array(52),
            createCardPicker: function() {
                return () => {
                    return this.suits[0];
                }
            }
        }

        let cardPicker2 = deck.createCardPicker();
        let pickedCard2 = cardPicker();
        // JS 변환시  -------------------
        // return "function()" 사용시
        var deck = {
            suits: ["hearts", "spades", "clubs", "diamonds"],
            cards: Array(52),
            createCardPicker: function () {
                return function () {
                    return this.suits[0];
                };
            }
        };
        var cardPicker = deck.createCardPicker();
        var pickedCard = cardPicker();
        // return "() =>" 사용시
        var deck2 = {
            suits: ["hearts", "spades", "clubs", "diamonds"],
            cards: Array(52),
            createCardPicker: function () {
                var _this = this;       // 다라진 부분 (변수캡쳐링)
                return function () {
                    return _this.suits[0];
                };
            }
        };
        var cardPicker2 = deck.createCardPicker();
        var pickedCard2 = cardPicker();        
        ```

        - this parameters
            > this의 타입이 any 인 경우
            > --noImplicitThis는 오류를 발생시키지 않습니다.
            ```typescript
            interface Card {
                suit: string;
                card: number;
            }
            interface Deck {
                suits: string[];
                cards: number[];
                createCardPicker(this: Deck): () => Card;
            }
            let deck: Deck = {
                suits: ["hearts", "spades", "clubs", "diamonds"],
                cards: Array(52),
                // 주의사항 : 이 함수는 이제 반드시 Deck 타입이어야합니다
                createCardPicker: function(this: Deck) {
                    return () => {
                        let pickedCard = Math.floor(Math.random() * 52);
                        let pickedSuit = Math.floor(pickedCard / 13);
                        
                        // this는 any가 아닌 Deck 타입입니다
                        return {suit: this.suits[pickedSuit], card: pickedCard % 13};
                    }
                }
            }

            let cardPicker = deck.createCardPicker();
            let pickedCard = cardPicker();

            alert("card: " + pickedCard.card + " of " + pickedCard.suit);
            ```

            - 콜백에서의 this 매개변수
            > 콜백에서 this를 사용할 경우 우회 방법
            ```typescript
            // 사례1 : 오류
            class Handler {
                info: string;
                onClickBad(this: Handler, e: Event) {
                    // 이런, 여기서 this를 사용했어요. 이 콜백을 사용하면 충돌으로 런타임 오류가 발생합니다.
                    this.info = e.message;
                }
            }
            let h = new Handler();
            uiElement.addClickListener(h.onClickBad); // 오류!

            // 사례2 : this 를 사용 못함
            class Handler {
                info: string;
                onClickGood(this: void, e: Event) {
                    // this의 타입이 void이기 때문에 여기서는 사용할 수 없습니다!
                    console.log('clicked!');
                }
            }
            let h = new Handler();
            uiElement.addClickListener(h.onClickGood);
            
            // 사례3 : 동작하며 this 사용가능함 (화살표 함수)
            // 단점 : 객체마다 함수가 생성된다
            class Handler {
                info: string;
                onClickGood = (e: Event) => { this.info = e.message }
            }
            // JS 변환시  -------------------
            // 화상표 함수를 사용한 경우
            var Handler2 = /** @class */ (function () {
                function Handler2() {
                    var _this = this;
                    this.onClickGood = function (e) { _this.info = e.message; };
                }
                return Handler2;
            }());
            ```

    - 오버로드 (함수)
    > - 매우 드문 경우임
    > - 입력타입에 따라 리턴타입이 다르게 선언함 (타입 추론가능)
    ```typescript
    function pickCard(x: string): string;
    function pickCard(x: number): number;
    function pickCard(x): any {
        // 객체 / 배열로 작업하고 있는지 확인해보세요
        // 그렇다면 그것들은 덱을 주고 사용자는 카드를 선택할 것입니다.
        if (typeof x == "string") {
            return "문자열";
        }
        // 그렇지 않으면 카드를 선택하게하세요.
        else if (typeof x == "number") {
            return 10;
        }
    }
    ```

-----------------------------------------
- 제네릭
    > 대형 소프트웨어 구축을 위해 유연한 기능 제공

    - 제네릭의 Hello World
    > 스코프 시작위치에 <T> 타입변수 정의
    ```typescript
    // 기본형, 단점: 고정된 타입만 사용
    function identity(arg: number): number {
        return arg;
    }

    // any형(동적 입력/리턴 타입), 단점: 타입정보가 없다
    function identity(arg: any): any {
        return arg;
    }

    // 타입변수(선언=타입변수정의, 호출=타입지정) 
    function identity<T>(arg: T): T {
        return arg;
    }

    // 호출방법1 : 명시적 지정
    let output = identity<string>("myString");  // 반환 타입은 'string' 입니다.

    // 호출방법2 : 타입 인수 추론 (인수값의 타입에 따라 T를 정함)
    // 복합한 예제의 경우, 명시적 지정이 유리함
    let output = identity("myString");  // 반환 타입은 'string' 입니다.
    ```

    - 제네릭 타입 변수
    > 배열 + 제네릭
    ```typescript
    // 방법1 : [] 표기법(기존방식과의 이해)
    function loggingIdentity<T>(arg: T[]): T[] {
        console.log(arg.length);  // Array는 .length 멤버가 있습니다. 오류 없음.
        return arg;
    }

    // 방법2 : 제네릭 표기법
    function loggingIdentity<T>(arg: Array<T>): Array<T> {
        console.log(arg.length);  // Array는 .length 멤버가 있습니다. 오류 없음.
        return arg;
    }
    ```

    - 제네릭 타입
    > - 제네릭 인터페이스, 제네릭 클래스 (객체 리터럴 타입) 가능
    > - 제네릭 열거형과 네임스페이스는 만들수 없음
    ```typescript
    function identity<T>(arg: T): T {
        return arg;
    }

    // 제네릭 함수 선언
    let myIdentity: <T>(arg: T) => T = identity;

    // 제네릭 변수명을 다르게 표현(T=>U)
    let myIdentity: <U>(arg: U) => U = identity;

    // 객체 리터럴에 사용
    let myIdentity: {<T>(arg: T): T} = identity;


    // 제네릭 함수 선언 부분을 인터페이스로 정의
    // "<T>(arg: T) => T" 의 별칭 개념
    interface GenericIdentityFn {
        <T>(arg: T): T;
    }
    let myIdentity: GenericIdentityFn = identity;

    // 호출형식의 고정 **
    interface GenericIdentityFn<T> {
        (arg: T): T;
    }
    let myIdentity: GenericIdentityFn<number> = identity;
    ```

    - 제네릭 클래스
    > C++의 템플릿클래스, C#의 제네릭클래스와 같은 개념
    > 제네릭클래스는 인스턴스적 측면이므로 정적(static)속성 사용불가
    ```typescript
    // 함수를 호출전에 본문 설정
    class GenericNumber<T> {
        zeroValue: T;
        add: (x: T, y: T) => T;
    }
    let myGenericNumber = new GenericNumber<number>();
    myGenericNumber.zeroValue = 0;
    myGenericNumber.add = function(x, y) { return x + y; };
    ```

    - 제네릭 제약조건
        > `extends` 인터페이스 확장 키워드를 제약조건으로 활용
        ```typescript
        // 제약조건 관점의 인터페이스
        interface Lengthwise {
            length: number;     // 'length' 속성 필수
        }

        function loggingIdentity<T extends Lengthwise>(arg: T): T {
            console.log(arg.length);  // 이제 .length 프로퍼티가 있으므로 더이상 오류가 없습니다.
            return arg;
        }

        loggingIdentity(3);  // 오류, number 는 .length 프로퍼티가 없습니다.
        loggingIdentity({length: 10, value: 3});
        loggingIdentity([1,2,3]);
        ```

        - 제네릭 제약조건에서 타입 매개변수 사용
        > 입력 매개변수의 속성을 제약조건으로 사용하는 경우
        ```typescript
        // obj(T)가 입력되면 obj의 속성은 key(K)의 제약조건이됨
        function getProperty<T, K extends keyof T>(obj: T, key: K) {
            return obj[key];
        }

        let x = { a: 1, b: 2, c: 3, d: 4 };

        getProperty(x, "a"); // 오류 없음
        getProperty(x, "m"); // 오류 : 타입 'm'의 인수를 'a' | 'b' | 'c' | 'd' 에 할당 할 수 없습니다.
        ```

        - 제네릭에서 클래스 타입 사용
        > 제네릭을 생성자 함수로 사용한 경우
        ```typescript
        // "c: { new(): T; }" {}로 묶여있고, ;로 끝낸다
        function create<T>(c: { new(): T; } ): T {
            return new c();
        }

        // 설명::
        // 함수 입력 매개변수의 타입이 A타입이 추론된다.
        // "A"는 콜백이면서 리턴타입이라는 의미
        function create<A extends Animal>(c: new () => A): A {
            return new c();
        }
        create(Lion)        
        ```

-----------------------------------------
- 열거형
    > 이름이 있는 상수 정의

    - 숫자 열거형
    ```typescript
    enum Direction {
        Up = 10,
        Down,
        Left,
        Right,
    }
    // JS 변환시  -------------------
    var Direction;
    (function (Direction) {
        Direction[Direction["Up"] = 10] = "Up";
        Direction[Direction["Down"] = 11] = "Down";
        Direction[Direction["Left"] = 12] = "Left";
        Direction[Direction["Right"] = 13] = "Right";
    })(Direction || (Direction = {}));    
    ```

    - 문자 열거형
    > 숫자열거형과 차이점 : 자동증가 안됨
    ```typescript
    enum Direction {
        Up = "UP",
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT",
    }
    // JS 변환시  -------------------
    var Direction;
    (function (Direction) {
        Direction["Up"] = "UP";
        Direction["Down"] = "DOWN";
        Direction["Left"] = "LEFT";
        Direction["Right"] = "RIGHT";
    })(Direction || (Direction = {}));
    ```

    - 별종 열거형 (숫자형 + 문자형)
    > 가능은 하지만 할 이유가 없다
    > 숫자형은 자동증가 됨
    ```typescript
    enum BooleanLikeHeterogeneousEnum {
        No = 0,
        Yes = "YES"
    }    
    ```

    - 계산된 상수 멤버
    > 
    ```typescript
    enum FileAccess {
        // 상수 멤버
        None,
        Read    = 1 << 1,           // 시프트 연산
        Write   = 1 << 2,           // 시프트 연산
        ReadWrite  = Read | Write,  // OR 연산
        // 계산된 멤버
        G = "123".length
    }
    // JS 변환시  -------------------    
    var FileAccess;
    (function (FileAccess) {
        // 상수 멤버
        FileAccess[FileAccess["None"] = 0] = "None";
        FileAccess[FileAccess["Read"] = 2] = "Read";
        FileAccess[FileAccess["Write"] = 4] = "Write";
        FileAccess[FileAccess["ReadWrite"] = 6] = "ReadWrite";
        // 계산된 멤버
        FileAccess[FileAccess["G"] = "123".length] = "G";
    })(FileAccess || (FileAccess = {}));      
    ```

    - 통합 열거형 및 열거형 멤버 타입
    > 열거형을 인터페이스, 클래스로 사용된 경우
    ```typescript
    enum ShapeKind {
        Circle,
        Square,
    }

    interface Circle {
        kind: ShapeKind.Circle;
        gg: ShapeKind;
        radius: number;
    }

    interface Square {
        kind: ShapeKind.Square;
        sideLength: number;
    }

    let c: Circle = {
        kind: ShapeKind.Circle,     // kind 는 상수의 의미임(고정)
        //kind: ShapeKind.Square,  // 오류, 상수를 수정
        gg: ShapeKind.Square,       // "Circle, Square" 선택가능
        radius: 100
    }

    function f(x: ShapeKind) {
        // if (x !== ShapeKind.Circle && x !== ShapeKind.Square) {
        if (x !== ShapeKind.Circle || x !== ShapeKind.Square) {
            // 오류, OR연산에서 True 가 반환되어 하위 계산 안함
            // AND 연산으로 바꾸면 유의미하게 사용 가능
        }
    }
    ```

    - 런타임시의 열거형
        > 지정된 타입(E)가 아닌 Object 로 넘길 경우
        ```typescript
        enum E {
            X, Y, Z
        }

        function f(obj: { X: number }) {
            return obj.X;
        }

        // 작동합니다. 왜냐하면 `E` 는 숫자인 `X` 라는 속성을 가지고있기 떄문입니다.
        f(E);
        ```

        - 역 매핑
        > 전방향 : name -> value
        > 역방향 : value -> name
        ```typescript
        enum Enum {
            A
        }
        let a = Enum.A;
        let nameOfA = Enum[a]; // "A"

        var Enum;
        (function (Enum) {
            Enum[Enum["A"] = 0] = "A";
        })(Enum || (Enum = {}));
        var a = Enum.A;
        var nameOfA = Enum[a]; // "A"
        var nameOfB = Enum[Enum.A]; // "A"        
        ```

        - const 열거형
        > 타입으로 정의가 안되고 값이 바로 지정된다.
        > ts 인터페이스와 같은 개념
        ```typescript
        const enum Directions {
            Up,
            Down,
            Left,
            Right
        }

        let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]
        // JS 변환시  -------------------
        var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
        ```

    - 앰비언트 열거형
    > delcare(정의)된 열거형은 상수와 반대로 이름이 바로 지정된다.
    ```typescript
    enum Direction {
        Up = 1,
        Down,
        Left,
        Right,
    }
    // 인터페이스 성격
    const enum ConstDirection {
        Up,
        Down,
        Left,
        Right
    }
    // 인터페이스 성격
    declare enum DeclareDirection {
        Up = 1,
        Down,
        Left,
        Right
    }

    let direction = Direction.Down;     // 열거형
    let constDirection = ConstDirection.Down;
    let declareDirection = DeclareDirection.Down;
    // JS 변환시  -------------------
    var Direction;
    (function (Direction) {
        Direction[Direction["Up"] = 1] = "Up";
        Direction[Direction["Down"] = 2] = "Down";
        Direction[Direction["Left"] = 3] = "Left";
        Direction[Direction["Right"] = 4] = "Right";
    })(Direction || (Direction = {}));
    var direction = Direction.Down;                 // 일반 열거형
    var constDirection = 1 /* Down */;              // 상수 열거형
    var declareDirection = DeclareDirection.Down;   // 정의 열거형
    ```

-----------------------------------------
- 타입 추론

    - 기본
    ```typescript
    let x = 3;  // number 로 추론됨
    ```

    - 최적 공통 타입
    > 최적의 공통 타입 알고니즘이 최적의 타입 지정
    > 사용자객체의 상위타입은 추론 안됨 (직접지정)
    ```typescript
    let x = [0, 1, null];   // number, null 타입
    
    let zoo = [new Rhino(), new Elephant(), new Snake()];
    // (Rhino | Elephant | Snake)[] 유니언타입

    // 해결방법 (상위타입 직접 지정)
    let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
    ```

    - 상황적 타입
    > 문맥적으로 타입을 해석함
    > 경우 : 함수 호출인수, 할당의 오른쪽, 타입단언, 객체/배열 리터럴의 맴버, 반환문
    ```typescript
    // button로 프로퍼티로 추론함
    window.onmousedown = function(mouseEvent) {
        console.log(mouseEvent.button);   //<- 성공
        console.log(mouseEvent.kangaroo); //<- 오류!
    };

    // UIEvent로 추촌함
    window.onscroll = function(uiEvent) {
        console.log(uiEvent.button); //<- 오류!
    }

    // any 타입으로 추론함
    const handler = function(uiEvent) {
        console.log(uiEvent.button); //<- 성공
    }

    // 타입 any 타입 재정의
    window.onscroll = function(uiEvent: any) {
        console.log(uiEvent.button);  //<- 이제 오류가 발생하지 않음
    };

    // 최적의 공통 타입으로 Animal 지정
    function createZoo(): Animal[] {
        return [new Rhino(), new Elephant(), new Snake()];
    }
    ```

-----------------------------------------
- 타입 호환성
    - 소개
        > - 타입호환성은 구조적 서브 타이핑에 기반함
        > - `맴버가 같으면 같은 타입임 (중요)`
        ```typescript
        interface Named {
            name: string;
        }

        class Person {
            name: string;
        }

        let p: Named;
        // 성공, 구조적 타이핑이기 때문입니다.
        p = new Person();
        ```

        - 안정성에 대한 노트
        > 컴파일시 타입이 확인이 안되면 불안정한 부분임(검토필요)

    - 시작하기
        > 동일한 멤버가 있으면 타입 호환됨
        ```typescript
        interface Named {
            name: string;
        }

        let x: Named;
        // y의 추론된 타입은 { name: string; location: string; } 입니다.
        let y = { name: "Alice", location: "Seattle" };
        x = y;

        // 지정된 타입에 할당해도 호환됨
        function greet(n: Named) {
            console.log("Hello, " + n.name);
        }
        greet(y); // 성공
        ```

        - 두 함수 비교
        ```typescript
        ```

        - 함수 매개변수의 Beveriance
        ```typescript
        ```

        - 선택적 매개 변수와 나머지 매게 변수
        ```typescript
        ```

        - 오버로드 함수
        ```typescript
        ```

    - 열거형
    ```typescript
    ```

    - 클래스
        ```typescript
        ```

        - 클래스의 Private와 Protected 멤버
        ```typescript
        ```

    - 제네릭
    ```typescript
    ```

    - 고급 주제
        ```typescript
        ```

        - 하위 타입 vs 할당
        ```typescript
        ```

-----------------------------------------
- 고급 타입
    ```typescript
    ```

    - 교차 타입
    ```typescript
    ```

    - 유니온 타입
    ```typescript
    ```

    - 타입 가드와 차별된 타입
        ```typescript
        ```

        - 사용자 정의 타입 가드
        ```typescript
        ```

        - typeof 타입 가드
        ```typescript
        ```

        - instanceof 타입 가드
        ```typescript
        ```

    - nullalble types
        ```typescript
        ```

        - 선택적 매개변수와 프로퍼티
        ```typescript
        ```

        - 타입 가드와 타입 단언
        ```typescript
        ```

    - 타입 별칭
        ```typescript
        ```

        - interfaces VS Type Aliases
        ```typescript
        ```

    - 문자열 리터럴 타입
    ```typescript
    ```

    - 숫자 리터럴 타입
    ```typescript
    ```

    - 열거형 멤버 타입
    ```typescript
    ```

    - 유니온 식별
        ```typescript
        ```

        - 철저한 검사
        ```typescript
        ```

    - 다형성의 this 타입
    ```typescript
    ```
    - 인덱스 타입
        ```typescript
        ```

        - 인덱스 타입과 문자열 인덱스 시그니처
        ```typescript
        ```

    - Mapped types    
        ```typescript
        ```

        - mapped types의 추론
        ```typescript
        ```        
-----------------------------------------
- 심볼
        ```typescript
        ```

    - 소개
    ```typescript
    ```
    - 잘 알려진 심볼
        ```typescript
        ```

        - Symbol.hasInstance
        ```typescript
        ```

        - Symbol.isConcatSpreadable
        ```typescript
        ```

        - Symbol.iterator
        ```typescript
        ```

        - Symbol.match
        ```typescript
        ```

        - Symbol.replace

        ```typescript
        ```
        - Symbol.search
        ```typescript
        ```

        - Symbol.species
        ```typescript
        ```

        - Symbol.split
        ```typescript
        ```

        - Symbol.toPremitive
        ```typescript
        ```

        - Symbol.toStringTag
        ```typescript
        ```

        - Symbol.unscopables
        ```typescript
        ```

-----------------------------------------
- 이터레이터와 제네레이터
    ```typescript
    ```

    - 이터러블
    ```typescript
    ```

    - for..of 문
        ```typescript
        ```

        - for..of VS for..in 문
        ```typescript
        ```

        - 코드 생성
            ```typescript
            ```

            - ES3와 ES5대상
            ```typescript
            ```

            - ECMAScript20015 이상 대상
            ```typescript
            ```

-----------------------------------------
- 모듈
    ```typescript
    ```

    - 소개
        ```typescript
        ```
        - 내보내기
        ```typescript
        ```

        - 내보내기 선언
        ```typescript
        ```

        - 내보내기 문
        ```typescript
        ```

        - 다시 내보내기
        ```typescript
        ```

    - Import
        ```typescript
        ```

        - 모듈에서 단일 내보내기 가져오기
        ```typescript
        ```

        - 전체모듈을 단일 변수로 가져오고 이를 사용하여 모듈 내보내기에 접근하기
        ```typescript
        ```

        - 부수 효과에 대한 모듈만 가져오기
        ```typescript
        ```

    - 기본 내보내기
    ```typescript
    ```

    - export = AND import = require()
    ```typescript
    ```

    - 모듈을 위한 코드 생성
    ```typescript
    ```

    - 간단한 예제
    ```typescript
    ```

    - 선택적 모듈 로딩과 기타 고급 로딩 사나리오
    ```typescript
    ```

    - 다른 javaScript 라이브러리 사용
        ```typescript
        ```

        - Ambient Modules
            ```typescript
            ```

            - Shorthand ambient modules
            ```typescript
            ```

            - Wildcard module declarations
            ```typescript
            ```

            - UMD modules
            ```typescript
            ```

    - 모듈 구조화를 위한 가이드
        ```typescript
        ```

        - 최상위 레벨에 가깝게 내보내기
            ```typescript
            ```

            - 단일 class 또는 function 만 export하는 경우  export default 를 사용하세요
            ```typescript
            ```
            
            - 다수의 객체를 내보내는 경우 모두 취상위 레벨에 배치하세요
            ```typescript
            ```

            - imported 이름을 명시적으로 나열
            ```typescript
            ```

            - 다수를 importing 하는 경우 네임스페이스 import 패턴 사용
            ```typescript
            ```

        - 확장을 위한 다시 내보내기
        ```typescript
        ```

        - 모듈에서 네임스페이스를 사용하지 마세요
        ```typescript
        ```

        - 위험 신호
        ```typescript
        ```

-----------------------------------------
- 네임스페이스
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 첫 걸음
        ```typescript
        ```

        - 단일 파일의 유효성 검사하기
        ```typescript
        ```

    - Namespacing
        ```typescript
        ```

        - Namespaced Validators
        ```typescript
        ```

    - 파일 분할
        ```typescript
        ```

        - Multi-file namespaces
        ```typescript
        ```

    - 별칭
    ```typescript
    ```

    - 다른 JavsScript 라이브러리로 작업하기
        ```typescript
        ```

        - Ambient Namespaces
        ```typescript
        ```

-----------------------------------------
- 네임스페이스와 모듈
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 네임스페이스 사용하기
    ```typescript
    ```

    - 모듈 사용하기
    ```typescript
    ```

    - 네임스페이스와 모듈의 위험
        ```typescript
        ```

        - /// <reference> -ing a module
        ```typescript
        ```

        - 불필요한 네임스페이스
        ```typescript
        ```

        - 모듈의 관계
        ```typescript
        ```

-----------------------------------------
- 모듈 해석
    ```typescript
    ```

    - 상대적 VS 비-상대적 모듈 import
    ```typescript
    ```

    - 모듈 해석 전략
        ```typescript
        ```

        - 클래식
        ```typescript
        ```

        - 노드
        ```typescript
        ```

            - Node.js 모듈 해석 방식
        ```typescript
        ```

            - TypeScript 모듈 해석 방법
        ```typescript
        ```

    - 추가적인 모듈 해석 알리기
        ```typescript
        ```

        - Base URL
        ```typescript
        ```

        - 경로 매핑
        ```typescript
        ```

        - rootDirs 디렉토리
        ```typescript
        ```

    - 모듈 해석 추적
    ```typescript
    ```

    - --noResolve 사용하기
    ```typescript
    ```

    - 공통 질문
        ```typescript
        ```

        - 제외 목록에 있는 모듈을 여전히 커파일러가 선택하는 이유는 무엇입니까?
        ```typescript
        ```

-----------------------------------------
- 선언 병합
    ```typescript
    ```

    - 기본 개념
    ```typescript
    ```

    - 인터페이스 병합
    ```typescript
    ```

    - 네임스페이스 병합
    ```typescript
    ```

    - 클래스, 함수 그리고 열거형 병합
        ```typescript
        ```

        - 클래스와  네임스페이스 병합
        ```typescript
        ```

    - 허용되지 않는 병합
    ```typescript
    ```

    - 모듈 확대
        ```typescript
        ```

        - 전역 확대
        ```typescript
        ```

-----------------------------------------
- JSX
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 기본 사용 방법
    ```typescript
    ```

    - as 연산자
    ```typescript
    ```

    - 타입 검사
        ```typescript
        ```

        - 내장 요소
        ```typescript
        ```

        - 값-기반 요소
            ```typescript
            ```

            - 무상태 함수형 컴포넌트
            ```typescript
            ```

            - 클래스 컴포넌트
            ```typescript
            ```

        - 속성 타입 검사
        ```typescript
        ```

        - 하위 타입 검사
        ```typescript
        ```

    - JSX 결과 타입
    ```typescript
    ```

    - 표현식 포함하기
    ```typescript
    ```

    - 리액트 통합
    ```typescript
    ```

-----------------------------------------
- 데코레이터
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 데코레이터
        ```typescript
        ```

        - 데코레이터 팩토리
        ```typescript
        ```

        - 데코레이터 구성
        ```typescript
        ```

        - 데코레이터 평가
        ```typescript
        ```

        - 클래스 데코레이터
        ```typescript
        ```

        - 메서드 데코레이터
        ```typescript
        ```

        - 접근제어자 데코레이터
        ```typescript
        ```

        - 프로퍼티 데코레이터    
        ```typescript
        ```

        - 매게변수 데코레이터
        ```typescript
        ```

        - 메타 데이터
        ```typescript
        ```

-----------------------------------------
- 믹스인
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 믹스인 샘플
    ```typescript
    ```

    - 샘플 이해하기
    ```typescript
    ```

-----------------------------------------
- 트리플-스럴시 지시자
    ```typescript
    ```

    - /// < reference path="..." />
        ```typescript
        ```

        - 전처리기 입력 파일
        ```typescript
        ```

        - 오류
        ```typescript
        ```

    - --noResolve 사용
    ```typescript
    ```

    - /// < reference type="..." />
    ```typescript
    ```

    - /// < reference no-default-lib="true"/>
    ```typescript
    ```

    - /// < amd-module />
    ```typescript
    ```

    - /// < amd-dependency />
    ```typescript
    ```

-----------------------------------------
- JavaScript 파일 타입 검사
    ```typescript
    ```

    - JSDoc에서 타입 사용
    ```typescript
    ```

    - 클래스 본문 할당에서 추론된 프로퍼티 선언
    ```typescript
    ```

    - CommonJS 모듈 입력 지원
    ```typescript
    ```

    - 객체 리터럴에서 제한이 없습니다.
    ```typescript
    ```

    - 함수 매게변수는 기본적으로 선택적입니다    
    ```typescript
    ```

    - arguments 의 사용으로 추론된 Var-args 매개변수
    ```typescript
    ```

    - 지정되지 않은 타입 매게 변수의 기본값은 any 입니다
    ```typescript
    ```

-----------------------------------------

