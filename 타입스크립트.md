## 타입스크립트

    ```typescript
    ```

### 구조
> 구조에 대해서 알아 본다.

- 기본타입
    - 부울 (Boolean)
    ```typescript
    let isDone: boolean = false;
    ```

    - 숫자형 (Number)
    ```typescript
    let decimal: number = 10;
    ```

    - 문자열 (String) 
    ```typescript
    let color: string = "blue";
    ```

    - 배열 (Array)
    ```typescript
    let list: number[] = [1, 2, 3];
    let list: Array<number> = [1, 2, 3]; // 제네릭 방식
    let list: [] // ?
    ```

    - 튜플 (Tuble)
    > 배열의 각각의 타입의 지정하는 방식
    ```typescript
    let x2: [string, number] = ["hello", 10]; // 좋아요
    ```

    - 열거 (Enum)
    ```typescript
    enum Color {Red, Green, Blue}
    let c: Color = Color.Green;
        
    // js로 변환시
    var Color;
    (function (Color) {
        Color[Color["Red"] = 0] = "Red";
        Color[Color["Green"] = 1] = "Green";
        Color[Color["Blue"] = 2] = "Blue";
    })(Color || (Color = {}));
    var c = Color.Green;

    // 속성을 2번 세팅한 효과를 가짐
    Color["Red"] = 0;   // 내부
    Color[0] = "Red";   // 외부
    
    //----------- 속성값을 임의로 지정 ----------
    // 지정한 수(10)에서 자동 증가됨
    enum Color {Red = 10, Green, Blue}  // 10,11,12
    ```

    - Any
    > c#의 Object 취상위 성격
    > 타입을 알지 못할때
     ```typescript
    let aaa: any = 4;
    ```

    - Void
    > Any의 반대 의미, 반환(return)이 없는 경우
    > undefined 타입만 선언 할당할 수 있음
     ```typescript
    let aaa: void = undefined;

    function warn() : void {
        alert("리턴타입이 없는 경우");
    }
    ```

    - Null 과 Undefined
    > 유용하지 않은 방법
    > 모든 타입은 null, undefined를 할당 가능
    > --strictNullChecks  옵션으로 void 타입에만 할당 가능
     ```typescript
    let u: undefined = undefined;
    let n: null = null;
    ```    

    - Never
    > 절대로 발생하지 않는 값, 예외
     ```typescript
    function error(msg: string): never {
        throw new Error(msg);
    }
    ```

    - 타입 단언 (Type assertions)
    > java의 강제캐스팅의 개념
     ```typescript
    let some: any = "ABCD";
    let value: number;

    // 강제로 타입 단언(캐스팅)
    value = (<string>some).length;      // 방법1
    value = (some as string).length;    // 방법2
    ```

    - let 에 대한 메모
-----------------------------------------
- 변수 선언
    - var 선언
        > var 의 결함을 피하기 위해서 : let, const
        >   - let : 타입을 선언하고 사용하는 방식
        >   - const : let 규칙 +  초기화 후 수정 불가
        >
        ```typescript
        var a = 10;
        ```

        - 스코프 규칙
        > var-scoping 또는 function-scoping
        ```typescript
        function f(shouldInitialize: boolean) {
            if (shouldInitialize) {
                var x = 10;
            }

            return x;
        }

        f(true);  // '10' 반환
        f(false); // 'undefined' 반환
        ```

        - 변수 캡쳐링의 단점
        ```typescript
        for (var i = 0; i < 10 ; i++) {
            
            // 변수가 캡쳐링 되어 모든 값이 '10'이 적됨
            setTimeout(function() { console.log(i); }, 100 * i);

            // IIEF 로 해결
            (function(i) {
                setTimeout(function() { console.log(i); }, 100 * i);
            })(i);
        }
        ```

    - let 선언
        - 블록-스코프
        > var과 차이점 블럭 스코프 외부에서는 사용 불가함
        > let은 선언 이전에 접근하면 오류 발생
        ```typescript
        let hello = "World!";

        function f(input: boolean) {
            let a = 100;

            if (input) {
                // 'a'는 이곳에서 가능
                let b = a + 1;
                return b;
            }

            // 오류: 'b'는 여기에 존재하지 않습니다.
            return b;
        }
        ```

        - 재선언과 Shadowing
        > var : 중복 선언 가능
        > let : 중복 선언 불가 (다른 블럭에 선언은 가능)
        > shadowing : 중첩된 블럭에서 기본 변수 이름 사용 (피해야함)
        ```typescript
        var x;
        var x;

        let x = 10;
        let x = 20; // 오류: 동일한 스코프에서 'x'를 다시 선언 할 수 없습니다.
        ```        

        - 블록-스코프 변수 캡쳐
        > var 과 let은 변환되는 방식이 다르다.
        ```typescript
        for (let i = 0; i < 10 ; i++) {
            setTimeout(function() { console.log(i); }, 100 * i);
        }

        // js 로 변환시 : 자동으로 변환하야 IIFE 블럭 사용을 피할 수 있다
        for (var i_1 = 0; i_1 < 10; i_1++) {
            _loop_1(i_1);
        }
        for (var i = 0; i < 10; i++) {
            setTimeout(function () { console.log(i); }, 100 * i);
        }
        ``` 

    - const 선언
    > - 상수 (타입은 지정 안함)
    > - 객체(클래스)에서 상수는 `readonly`지정
    > - const 외부 vs readonly 내부
    ```typescript
    const numLivesForCat = 9;
    
    const kitty = {
        name: "Aurora",
        numLives: numLivesForCat,
    }    
    ```

    - let vs const
    > 최소 권한 원칙 : const > let > var

    - 비구조화
        > 배열에 배열을 강제 할당하는 방식
        > 타입을 지정하지 않고, 배열:배열 방식으로 할당

        - 배열 비구조화
        ```typescript
        let input = [1, 2];
        let [first, second] = input;
        console.log(first); // 1 출력
        console.log(second); // 2 출력        
        // JS 변환시  -------------------
        var input = [1, 2];
        var first = input[0], second = input[1];

        // 동일함
        first = input[0];
        second = input[1];

        // 변수 교환
        [first, second] = [second, first];
        // JS 변환시  -------------------
        _a = [second, first], first = _a[0], second = _a[1];        

        // 특수한 경우들
        function f([first, second]: [number, number]) {
            console.log(first);
            console.log(second);
        }
        // JS 변환시  -------------------
        function f(_a) {
            var first = _a[0], second = _a[1];
            console.log(first);
            console.log(second);
        }

        let [first, ...rest] = [1, 2, 3, 4];
        console.log(first); // 1 출력
        console.log(rest); // [ 2, 3, 4 ] 출력
        // JS 변환시  -------------------
        var _b = [1, 2, 3, 4], first = _b[0], rest = _b.slice(1);

        let [first] = [1, 2, 3, 4];
        console.log(first); // 1 출력
        // JS 변환시  -------------------
        var first = [1, 2, 3, 4][0];

        let [, second, , fourth] = [1, 2, 3, 4];
        // JS 변환시  -------------------
        var _b = [1, 2, 3, 4], second = _b[1], fourth = _b[3];
        ```

        - 객체 비구조화
            > 객체를 해제(분리) 할때 사용
            ```typescript
            let o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            let { a, b } = o;
            // JS 변환시  -------------------
            var o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            var a = o.a, b = o.b;

            // 선언 없이 할당 (괄호를 묶는다)
            ({ a, b } = { a: "baz", b: 101 });
            // JS 변환시  -------------------
            (_b = { a: "baz", b: 101 }, a = _b.a, b = _b.b);
            
            // ... 구문으로 객체의 나머지를 변수로 해체할 수 있다
            let { a, ...passthrough } = o;
            let total = passthrough.b + passthrough.c.length;
            // JS 변환시  -------------------
            var __rest = (this && this.__rest) || function (s, e) {
                var t = {};
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                    t[p] = s[p];
                if (s != null && typeof Object.getOwnPropertySymbols === "function")
                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                            t[p[i]] = s[p[i]];
                    }
                return t;
            };
            var o = {
                a: "foo",
                b: 12,
                c: "bar"
            };
            var a = o.a, passthrough = __rest(o, ["a"]);
            var total = passthrough.b + passthrough.c.length;
            ```

            - 프로퍼티 이름 변경
            > REVIEW:: 검토 필요!!
            ```typescript
            let { a: newName1, b: newName2 } = o;
            // JS 변환시  -------------------
            var newName1 = o.a, newName2 = o.b;
            ```

            - 기본값
            > 전달객체의 속성값이 없는경우 기본값을 지정 가능함
            ```typescript
            function keepWholeObject(wholeObject: { a: string, b?: number }) {
                let { a, b = 1001 } = wholeObject; // 기본값 지정
            }
            // JS 변환시  -------------------
            function keepWholeObject(wholeObject) {
                var a = wholeObject.a
                var _a = wholeObject.b
                var b = _a === void 0 ? 1001 : _a;
            }
            ```            
        - 함수 선언
        > 비구조화는 조심히사용 (혼란)
        ```typescript
        type C = { a: string, b?: number }
        function f({ a, b }: C): void {
            // ...
        }
        // JS 변환시  -------------------
        function f(_a) {
            var a = _a.a, b = _a.b;
            // ...
        }

        function f({ a, b = 0 } = { a: "" }): void {
            // ...
        }
        f({ a: "yes" }); // 좋아요, 기본값 b = 0
        f(); // 좋아요, 기본값은 { a:"" }이며 이 경우 기본값은 b = 0입니다.
        f({}); // 오류, 인수를 제공하려면 'a'가 필요합니다.
        ```

        - 전개 연산자
        > 비고조화의 반대의미
        > 배열 : 얕은 복사
        > 객체 : 왼쪽에서 오른쪽으로 진행하며 이전객체에 덮어씀
        > **주의사항**  객체의 복사시 메소드 복사 안됨
        ```typescript
        let first = [1, 2];
        let second = [3, 4];
        let bothPlus = [0, ...first, ...second, 5];
        // bothPlus에 [0, 1, 2, 3, 4, 5]

        let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
        let search = { ...defaults, food: "rich" }; // food 위치가 다름
        // search의 값은 { food: "rich", price: "$$", ambiance: "noisy" }

        let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
        let search = { ...defaults, food: "rich" }; // food 위치가 다름
        //search의 값은 { food: "spicy", price: "$$", ambiance: "noisy" }

        class C {
        p = 12;
        m() {
        }
        }
        let c = new C();
        let clone = { ...c };
        clone.p; // 좋아요
        clone.m(); // 오류!
        ```

-----------------------------------------
- 인터페이스
    ```typescript
    ```

    - 첫번재 인터페이스
    ```typescript
    ```
    - 선택적 프로퍼티
    ```typescript
    ```

    - 읽기 전용 프로퍼티
    ```typescript
    ```

    - 프로퍼티 초과 검사
    ```typescript
    ```

    - 함수 타입
    ```typescript
    ```

    - 인덱싱 가능 타입
    ```typescript
    ```

    - 클래스 타입
        ```typescript
        ```

        - 인터페이스 구현
        ```typescript
        ```

        - 클래스 스태틱과 인스턴스의 차이점
        ```typescript
        ```

    - 인터페이스 확장
    ```typescript
    ```

    - 하이브리드 타입
    ```typescript
    ```

    - 인터페이스 확장 클래스
    ```typescript
    ```

-----------------------------------------
- 클래스
    - 클래스
    ```typescript
    ```

    - 상속
    ```typescript
    ```

    - Public, private, protected 지정자
        ```typescript
        ```

        - 기본적인 public
        ```typescript
        ```

        - private 이해하기
        ```typescript
        ```

        - protected 이해하기
        ```typescript
        ```

    - Readonly 지정자
        - 매개변수 프로퍼티
        ```typescript
        ```

    - 접근자
    ```typescript
    ```

    - 정적 프로퍼티
    ```typescript
    ```

    - 추상 클래스
    ```typescript
    ```

    - 고급기법
        ```typescript
        ```

        - 생성자 함수
        ```typescript
        ```

        - 클래스를 인터페이스로 사용하기
        ```typescript
        ```

-----------------------------------------
- 함수
    - 함수
        ```typescript
        ```

    - 함수의 타입
        ```typescript
        ```

        - 함수 작성하기
        ```typescript
        ```        

        - 함수 타입 작성하기
        ```typescript
        ```
        - 타입 추론
        ```typescript
        ```

    - 선택적 매개변수와 기본 매개변수
    ```typescript
    ```

    - 나머지 매개변수
    ```typescript
    ```

    - this
        ```typescript
        ```

        - this와 화살표 함수
        ```typescript
        ```

        - this parameters
            ```typescript
            ```

            - 콜백에서의 this 매개변수
            ```typescript
            ```

    - 오버로드
    ```typescript
    ```

-----------------------------------------
- 제네릭
    ```typescript
    ```

    - 제네릭의 Hello World
    ```typescript
    ```

    - 제네릭 타입 변수
    ```typescript
    ```

    - 제네릭 타입
    ```typescript
    ```

    - 제네릭 클래스
    ```typescript
    ```

    - 제네릭 제약조건
        ```typescript
        ```

        - 제네릭 제약조건에서 타입 매개변수 사용
        ```typescript
        ```

        - 제네릭에서 클래스 타입 사용
        ```typescript
        ```

-----------------------------------------
- 열거형
    ```typescript
    ```

    - 숫자 열거형
    ```typescript
    ```

    - 문자 열거형
    ```typescript
    ```

    - 별종 열거형
    ```typescript
    ```

    - 계산된 상수 멤버
    ```typescript
    ```

    - 통합 열거형 및 열거형 멤버 타입
    ```typescript
    ```

    - 런타임시의 열거형
        ```typescript
        ```

        - 역 매핑
        ```typescript
        ```

        - const 열거형
        ```typescript
        ```

    - 앰비언트 열거형
    ```typescript
    ```

-----------------------------------------
- 타입 추론
    ```typescript
    ```

    - 기본
    ```typescript
    ```

    - 가장 일반적인 타입
    ```typescript
    ```

    - 상황적 타입
    ```typescript
    ```

-----------------------------------------
- 타입 호환성
    - 소개
        ```typescript
        ```

        - 안정성에 대한 노트
        ```typescript
        ```

    - 시작하기
        ```typescript
        ```

        - 두 함수 비교
        ```typescript
        ```

        - 함수 매개변수의 Beveriance
        ```typescript
        ```

        - 선택적 매개 변수와 나머지 매게 변수
        ```typescript
        ```

        - 오버로드 함수
        ```typescript
        ```

    - 열거형
    ```typescript
    ```

    - 클래스
        ```typescript
        ```

        - 클래스의 Private와 Protected 멤버
        ```typescript
        ```

    - 제네릭
    ```typescript
    ```

    - 고급 주제
        ```typescript
        ```

        - 하위 타입 vs 할당
        ```typescript
        ```

-----------------------------------------
- 고급 타입
    ```typescript
    ```

    - 교차 타입
    ```typescript
    ```

    - 유니온 타입
    ```typescript
    ```

    - 타입 가드와 차별된 타입
        ```typescript
        ```

        - 사용자 정의 타입 가드
        ```typescript
        ```

        - typeof 타입 가드
        ```typescript
        ```

        - instanceof 타입 가드
        ```typescript
        ```

    - nullalble types
        ```typescript
        ```

        - 선택적 매개변수와 프로퍼티
        ```typescript
        ```

        - 타입 가드와 타입 단언
        ```typescript
        ```

    - 타입 별칭
        ```typescript
        ```

        - interfaces VS Type Aliases
        ```typescript
        ```

    - 문자열 리터럴 타입
    ```typescript
    ```

    - 숫자 리터럴 타입
    ```typescript
    ```

    - 열거형 멤버 타입
    ```typescript
    ```

    - 유니온 식별
        ```typescript
        ```

        - 철저한 검사
        ```typescript
        ```

    - 다형성의 this 타입
    ```typescript
    ```
    - 인덱스 타입
        ```typescript
        ```

        - 인덱스 타입과 문자열 인덱스 시그니처
        ```typescript
        ```

    - Mapped types    
        ```typescript
        ```

        - mapped types의 추론
        ```typescript
        ```        
-----------------------------------------
- 심볼
        ```typescript
        ```

    - 소개
    ```typescript
    ```
    - 잘 알려진 심볼
        ```typescript
        ```

        - Symbol.hasInstance
        ```typescript
        ```

        - Symbol.isConcatSpreadable
        ```typescript
        ```

        - Symbol.iterator
        ```typescript
        ```

        - Symbol.match
        ```typescript
        ```

        - Symbol.replace

        ```typescript
        ```
        - Symbol.search
        ```typescript
        ```

        - Symbol.species
        ```typescript
        ```

        - Symbol.split
        ```typescript
        ```

        - Symbol.toPremitive
        ```typescript
        ```

        - Symbol.toStringTag
        ```typescript
        ```

        - Symbol.unscopables
        ```typescript
        ```

-----------------------------------------
- 이터레이터와 제네레이터
    ```typescript
    ```

    - 이터러블
    ```typescript
    ```

    - for..of 문
        ```typescript
        ```

        - for..of VS for..in 문
        ```typescript
        ```

        - 코드 생성
            ```typescript
            ```

            - ES3와 ES5대상
            ```typescript
            ```

            - ECMAScript20015 이상 대상
            ```typescript
            ```

-----------------------------------------
- 모듈
    ```typescript
    ```

    - 소개
        ```typescript
        ```
        - 내보내기
        ```typescript
        ```

        - 내보내기 선언
        ```typescript
        ```

        - 내보내기 문
        ```typescript
        ```

        - 다시 내보내기
        ```typescript
        ```

    - Import
        ```typescript
        ```

        - 모듈에서 단일 내보내기 가져오기
        ```typescript
        ```

        - 전체모듈을 단일 변수로 가져오고 이를 사용하여 모듈 내보내기에 접근하기
        ```typescript
        ```

        - 부수 효과에 대한 모듈만 가져오기
        ```typescript
        ```

    - 기본 내보내기
    ```typescript
    ```

    - export = AND import = require()
    ```typescript
    ```

    - 모듈을 위한 코드 생성
    ```typescript
    ```

    - 간단한 예제
    ```typescript
    ```

    - 선택적 모듈 로딩과 기타 고급 로딩 사나리오
    ```typescript
    ```

    - 다른 javaScript 라이브러리 사용
        ```typescript
        ```

        - Ambient Modules
            ```typescript
            ```

            - Shorthand ambient modules
            ```typescript
            ```

            - Wildcard module declarations
            ```typescript
            ```

            - UMD modules
            ```typescript
            ```

    - 모듈 구조화를 위한 가이드
        ```typescript
        ```

        - 최상위 레벨에 가깝게 내보내기
            ```typescript
            ```

            - 단일 class 또는 function 만 export하는 경우  export default 를 사용하세요
            ```typescript
            ```
            
            - 다수의 객체를 내보내는 경우 모두 취상위 레벨에 배치하세요
            ```typescript
            ```

            - imported 이름을 명시적으로 나열
            ```typescript
            ```

            - 다수를 importing 하는 경우 네임스페이스 import 패턴 사용
            ```typescript
            ```

        - 확장을 위한 다시 내보내기
        ```typescript
        ```

        - 모듈에서 네임스페이스를 사용하지 마세요
        ```typescript
        ```

        - 위험 신호
        ```typescript
        ```

-----------------------------------------
- 네임스페이스
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 첫 걸음
        ```typescript
        ```

        - 단일 파일의 유효성 검사하기
        ```typescript
        ```

    - Namespacing
        ```typescript
        ```

        - Namespaced Validators
        ```typescript
        ```

    - 파일 분할
        ```typescript
        ```

        - Multi-file namespaces
        ```typescript
        ```

    - 별칭
    ```typescript
    ```

    - 다른 JavsScript 라이브러리로 작업하기
        ```typescript
        ```

        - Ambient Namespaces
        ```typescript
        ```

-----------------------------------------
- 네임스페이스와 모듈
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 네임스페이스 사용하기
    ```typescript
    ```

    - 모듈 사용하기
    ```typescript
    ```

    - 네임스페이스와 모듈의 위험
        ```typescript
        ```

        - /// <reference> -ing a module
        ```typescript
        ```

        - 불필요한 네임스페이스
        ```typescript
        ```

        - 모듈의 관계
        ```typescript
        ```

-----------------------------------------
- 모듈 해석
    ```typescript
    ```

    - 상대적 VS 비-상대적 모듈 import
    ```typescript
    ```

    - 모듈 해석 전략
        ```typescript
        ```

        - 클래식
        ```typescript
        ```

        - 노드
        ```typescript
        ```

            - Node.js 모듈 해석 방식
        ```typescript
        ```

            - TypeScript 모듈 해석 방법
        ```typescript
        ```

    - 추가적인 모듈 해석 알리기
        ```typescript
        ```

        - Base URL
        ```typescript
        ```

        - 경로 매핑
        ```typescript
        ```

        - rootDirs 디렉토리
        ```typescript
        ```

    - 모듈 해석 추적
    ```typescript
    ```

    - --noResolve 사용하기
    ```typescript
    ```

    - 공통 질문
        ```typescript
        ```

        - 제외 목록에 있는 모듈을 여전히 커파일러가 선택하는 이유는 무엇입니까?
        ```typescript
        ```

-----------------------------------------
- 선언 병합
    ```typescript
    ```

    - 기본 개념
    ```typescript
    ```

    - 인터페이스 병합
    ```typescript
    ```

    - 네임스페이스 병합
    ```typescript
    ```

    - 클래스, 함수 그리고 열거형 병합
        ```typescript
        ```

        - 클래스와  네임스페이스 병합
        ```typescript
        ```

    - 허용되지 않는 병합
    ```typescript
    ```

    - 모듈 확대
        ```typescript
        ```

        - 전역 확대
        ```typescript
        ```

-----------------------------------------
- JSX
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 기본 사용 방법
    ```typescript
    ```

    - as 연산자
    ```typescript
    ```

    - 타입 검사
        ```typescript
        ```

        - 내장 요소
        ```typescript
        ```

        - 값-기반 요소
            ```typescript
            ```

            - 무상태 함수형 컴포넌트
            ```typescript
            ```

            - 클래스 컴포넌트
            ```typescript
            ```

        - 속성 타입 검사
        ```typescript
        ```

        - 하위 타입 검사
        ```typescript
        ```

    - JSX 결과 타입
    ```typescript
    ```

    - 표현식 포함하기
    ```typescript
    ```

    - 리액트 통합
    ```typescript
    ```

-----------------------------------------
- 데코레이터
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 데코레이터
        ```typescript
        ```

        - 데코레이터 팩토리
        ```typescript
        ```

        - 데코레이터 구성
        ```typescript
        ```

        - 데코레이터 평가
        ```typescript
        ```

        - 클래스 데코레이터
        ```typescript
        ```

        - 메서드 데코레이터
        ```typescript
        ```

        - 접근제어자 데코레이터
        ```typescript
        ```

        - 프로퍼티 데코레이터    
        ```typescript
        ```

        - 매게변수 데코레이터
        ```typescript
        ```

        - 메타 데이터
        ```typescript
        ```

-----------------------------------------
- 믹스인
    ```typescript
    ```

    - 소개
    ```typescript
    ```

    - 믹스인 샘플
    ```typescript
    ```

    - 샘플 이해하기
    ```typescript
    ```

-----------------------------------------
- 트리플-스럴시 지시자
    ```typescript
    ```

    - /// < reference path="..." />
        ```typescript
        ```

        - 전처리기 입력 파일
        ```typescript
        ```

        - 오류
        ```typescript
        ```

    - --noResolve 사용
    ```typescript
    ```

    - /// < reference type="..." />
    ```typescript
    ```

    - /// < reference no-default-lib="true"/>
    ```typescript
    ```

    - /// < amd-module />
    ```typescript
    ```

    - /// < amd-dependency />
    ```typescript
    ```

-----------------------------------------
- JavaScript 파일 타입 검사
    ```typescript
    ```

    - JSDoc에서 타입 사용
    ```typescript
    ```

    - 클래스 본문 할당에서 추론된 프로퍼티 선언
    ```typescript
    ```

    - CommonJS 모듈 입력 지원
    ```typescript
    ```

    - 객체 리터럴에서 제한이 없습니다.
    ```typescript
    ```

    - 함수 매게변수는 기본적으로 선택적입니다    
    ```typescript
    ```

    - arguments 의 사용으로 추론된 Var-args 매개변수
    ```typescript
    ```

    - 지정되지 않은 타입 매게 변수의 기본값은 any 입니다
    ```typescript
    ```

-----------------------------------------

