## 타입스크립트

    ```typescript
    ```

### 구조
> 구조에 대해서 알아 본다.

- 기본타입
    - 부울 (Boolean)
    ```typescript
    let isDone: boolean = false;
    ```

    - 숫자형 (Number)
    ```typescript
    let decimal: number = 10;
    ```

    - 문자열 (String) 
    ```typescript
    let color: string = "blue";
    ```

    - 배열 (Array)
    ```typescript
    let list: number[] = [1, 2, 3];
    let list: Array<number> = [1, 2, 3]; // 제네릭 방식
    let list: [] // ?
    ```

    - 튜플 (Tuble)
    > 배열의 각각의 타입의 지정하는 방식
    ```typescript
    let x2: [string, number] = ["hello", 10]; // 좋아요
    ```

    - 열거 (Enum)
    ```typescript
    enum Color {Red, Green, Blue}
    let c: Color = Color.Green;
        
    // js로 변환시
    var Color;
    (function (Color) {
        Color[Color["Red"] = 0] = "Red";
        Color[Color["Green"] = 1] = "Green";
        Color[Color["Blue"] = 2] = "Blue";
    })(Color || (Color = {}));
    var c = Color.Green;

    // 속성을 2번 세팅한 효과를 가짐
    Color["Red"] = 0;   // 내부
    Color[0] = "Red";   // 외부
    
    //----------- 속성값을 임의로 지정 ----------
    // 지정한 수 (1)에서 자동 증가됨
    enum Color {Red = 10, Green, Blue}  // 10,11,12
    ```

    - Any
    > c#의 Object 취상위 성격
    > 타입을 알지 못할때
     ```typescript
    let aaa: any = 4;
    ```

    - Void
    > Any의 반대 의미, 반환(return)이 없는 경우
    > undefined 타입만 선언 할당할 수 있음
     ```typescript
    let aaa: void = undefined;

    function warn() : void {
        alert("리턴타입이 없는 경우");
    }
    ```

    - Null 과 Undefined
    > 유용하지 않은 방법
    > 모든 타입은 null, undefined를 할당 가능
    > --strictNullChecks  옵션으로 void 타입에만 할당 가능
     ```typescript
    let u: undefined = undefined;
    let n: null = null;
    ```    

    - Never
    > 절대로 발생하지 않는 값, 예외
     ```typescript
    function error(msg: string): never {
        throw new Error(msg);
    }
    ```

    - 타입 단언 (Type assertions)
    > java의 강제캐스팅의 개념
     ```typescript
    let some: any = "ABCD";
    let value: number;

    // 강제로 타입 단언(캐스팅)
    value = (<string>some).length;      // 방법1
    value = (some as string).length;    // 방법2
    ```

    - let 에 대한 메모

- 변수 선언
    - var 선언
        > var 의 결함을 피하기 위해서 : let, const
        > let : 타입을 선언하고 사용하는 방식
        > const : let 규칙 +  초기화 후 수정 불가
        ```typescript
        var a = 10;
        ```

        - 스코프 규칙
        > var-scoping 또는 function-scoping

        - 변수 캡쳐링의 단점
    - let 선언
        - 블록-스코프
        - 재선언과 Shadowing
        - 블록-스코프 변수 캡쳐
    - const 선언
    - let vs const
    - 비구조화
        - 배열 비구조화
        - 객체 비구조화
            - 프로퍼티 이름 변경
            - 기본값
        - 함수 선언
        - 전개 연산자

- 인터페이스
    - 첫번재 인터페이스
    - 선택적 프로퍼티
    - 읽기 전용 프로퍼티
    - 프로퍼티 초과 검사
    - 함수 타입
    - 인덱싱 가능 타입
    - 클래스 타입
        - 인터페이스 구현
        - 클래스 스태틱과 인스턴스의 차이점
    - 인터페이스 확장
    - 하이브리드 타입
    - 인터페이스 확장 클래스

- 클래스
    - 클래스
    - 상속
    - Public, private, protected 지정자
        - 기본적인 public
        - private 이해하기
        - protected 이해하기
    - Readonly 지정자
        - 매개변수 프로퍼티
    - 접근자
    - 정적 프로퍼티
    - 추상 클래스
    - 고급기법
        - 생성자 함수
        - 클래스를 인터페이스로 사용하기

- 함수
    - 함수
    - 함수의 타입
        - 함수 작성하기
        - 함수 타입 작성하기
        - 타입 추론
    - 선택적 매개변수와 기본 매개변수
    - 나머지 매개변수
    - this
        - this와 화살표 함수
        - this parameters
            - 콜백에서의 this 매개변수
    - 오버로드


- 제네릭
    - 제네릭의 Hello World
    - 제네릭 타입 변수
    - 제네릭 타입
    - 제네릭 클래스
    - 제네릭 제약조건
        - 제네릭 제약조건에서 타입 매개변수 사용
        - 제네릭에서 클래스 타입 사용

- 열거형
    - 숫자 열거형
    - 문자 열거형
    - 별종 열거형
    - 계산된 상수 멤버
    - 통합 열거형 및 열거형 멤버 타입
    - 런타임시의 열거형
        - 역 매핑
        - const 열거형
    - 앰비언트 열거형

- 타입 추론
    - 기본
    - 가장 일반적인 타입
    - 상황적 타입

- 타입 호환성
    - 소개
        - 안정성에 대한 노트
    - 시작하기
        - 두 함수 비교
        - 함수 매개변수의 Beveriance
        - 선택적 매개 변수와 나머지 매게 변수
        - 오버로드 함수
    - 열거형
    - 클래스
        - 클래스의 Private와 Protected 멤버
    - 제네릭
    - 고급 주제
        - 하위 타입 vs 할당

- 고급 타입
    - 교차 타입
    - 유니온 타입
    - 타입 가드와 차별된 타입
        - 사용자 정의 타입 가드
        - typeof 타입 가드
        - instanceof 타입 가드
    - nullalble types
        - 선택적 매개변수와 프로퍼티
        - 타입 가드와 타입 단언
    - 타입 별칭
        - interfaces VS Type Aliases
    - 문자열 리터럴 타입
    - 숫자 리터럴 타입
    - 열거형 멤버 타입
    - 유니온 식별
        - 철저한 검사
    - 다형성의 this 타입
    - 인덱스 타입
        - 인덱스 타입과 문자열 인덱스 시그니처
    - Mapped types    
        - mapped types의 추론

- 심볼
    - 소개
    - 잘 알려진 심볼
        - Symbol.hasInstance
        - Symbol.isConcatSpreadable
        - Symbol.iterator
        - Symbol.match
        - Symbol.replace
        - Symbol.search
        - Symbol.species
        - Symbol.split
        - Symbol.toPremitive
        - Symbol.toStringTag
        - Symbol.unscopables

- 이터레이터와 제네레이터
    - 이터러블
    - for..of 문
        - for..of VS for..in 문
        - 코드 생성
            - ES3와 ES5대상
            - ECMAScript20015 이상 대상

- 모듈
    - 소개
    - 내보내기
        - 내보내기 선언
        - 내보내기 문
        - 다시 내보내기
    - Import
        - 모듈에서 단일 내보내기 가져오기
        - 전체모듈을 단일 변수로 가져오고 이를 사용하여 모듈 내보내기에 접근하기
        - 부수 효과에 대한 모듈만 가져오기
    - 기본 내보내기
    - export = AND import = require()
    - 모듈을 위한 코드 생성
    - 간단한 예제
    - 선택적 모듈 로딩과 기타 고급 로딩 사나리오
    - 다른 javaScript 라이브러리 사용
        - Ambient Modules
            - Shorthand ambient modules
            - Wildcard module declarations
            - UMD modules
    - 모듈 구조화를 위한 가이드
        - 최상위 레벨에 가깝게 내보내기
            - 단일 class 또는 function 만 export하는 경우  export default 를 사용하세요
            - 다수의 객체를 내보내는 경우 모두 취상위 레벨에 배치하세요
            - imported 이름을 명시적으로 나열
            - 다수를 importing 하는 경우 네임스페이스 import 패턴 사용
        - 확장을 위한 다시 내보내기
        - 모듈에서 네임스페이스를 사용하지 마세요
        - 위험 신호

- 네임스페이스
    - 소개
    - 첫 걸음
        - 단일 파일의 유효성 검사하기
    - Namespacing
        - Namespaced Validators
    - 파일 분할
        - Multi-file namespaces
    - 별칭
    - 다른 JavsScript 라이브러리로 작업하기
        - Ambient Namespaces


- 네임스페이스와 모듈
    - 소개
    - 네임스페이스 사용하기
    - 모듈 사용하기
    - 네임스페이스와 모듈의 위험
        - /// <reference> -ing a module
        - 불필요한 네임스페이스
        - 모듈의 관계


- 모듈 해석
    - 상대적 VS 비-상대적 모듈 import
    - 모듈 해석 전략
        - 클래식
        - 노드
            - Node.js 모듈 해석 방식
            - TypeScript 모듈 해석 방법
    - 추가적인 모듈 해석 알리기
        - Base URL
        - 경로 매핑
        - rootDirs 디렉토리
    - 모듈 해석 추적
    - --noResolve 사용하기
    - 공통 질문
        - 제외 목록에 있는 모듈을 여전히 커파일러가 선택하는 이유는 무엇입니까?


- 선언 병합
    - 기본 개념
    - 인터페이스 병합
    - 네임스페이스 병합
    - 클래스, 함수 그리고 열거형 병합
        - 클래스와  네임스페이스 병합
    - 허용되지 않는 병합
    - 모듈 확대
        - 전역 확대

- JSX
    - 소개
    - 기본 사용 방법
    - as 연산자
    - 타입 검사
        - 내장 요소
        - 값-기반 요소
            - 무상태 함수형 컴포넌트
            - 클래스 컴포넌트
        - 속성 타입 검사
        - 하위 타입 검사
    - JSX 결과 타입
    - 표현식 포함하기
    - 리액트 통합


- 데코레이터
    - 소개
    - 데코레이터
        - 데코레이터 팩토리
        - 데코레이터 구성
        - 데코레이터 평가
        - 클래스 데코레이터
        - 메서드 데코레이터
        - 접근제어자 데코레이터
        - 프로퍼티 데코레이터    
        - 매게변수 데코레이터
        - 메타 데이터


- 믹스인
    - 소개
    - 믹스인 샘플
    - 샘플 이해하기


- 트리플-스럴시 지시자
    - /// <reference path="..." />
        - 전처리기 입력 파일
        - 오류
    - --noResolve 사용
    - /// <reference type="..." />
    - /// <reference no-default-lib="true"/>
    - /// <amd-module />
    - /// <amd-dependency />


- JavaScript 파일 타입 검사
    - JSDoc에서 타입 사용
    - 클래스 본문 할당에서 추론된 프로퍼티 선언
    - CommonJS 모듈 입력 지원
    - 객체 리터럴에서 제한이 없습니다.
    - 함수 매게변수는 기본적으로 선택적입니다    
    - arguments 의 사용으로 추론된 Var-args 매개변수
    - 지정되지 않은 타입 매게 변수의 기본값은 any 입니다